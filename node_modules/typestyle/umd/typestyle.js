(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["typestyle"] = factory();
	else
		root["typestyle"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var typestyle_1 = __webpack_require__(1);
	/**
	 * All the CSS types in the 'types' namespace
	 */
	var types = __webpack_require__(6);
	exports.types = types;
	/**
	 * Export certain utilities
	 */
	var utilities_1 = __webpack_require__(5);
	exports.extend = utilities_1.extend;
	exports.classes = utilities_1.classes;
	exports.media = utilities_1.media;
	/** Zero configuration, default instance of TypeStyle */
	var ts = new typestyle_1.TypeStyle({ autoGenerateTag: true });
	/** Sets the target tag where we write the css on style updates */
	exports.setStylesTarget = ts.setStylesTarget;
	/**
	 * Insert `raw` CSS as a string. This is useful for e.g.
	 * - third party CSS that you are customizing with template strings
	 * - generating raw CSS in JavaScript
	 * - reset libraries like normalize.css that you can use without loaders
	 */
	exports.cssRaw = ts.cssRaw;
	/**
	 * Takes CSSProperties and registers it to a global selector (body, html, etc.)
	 */
	exports.cssRule = ts.cssRule;
	/**
	 * Renders styles to the singleton tag imediately
	 * NOTE: You should only call it on initial render to prevent any non CSS flash.
	 * After that it is kept sync using `requestAnimationFrame` and we haven't noticed any bad flashes.
	 **/
	exports.forceRenderStyles = ts.forceRenderStyles;
	/**
	 * Utility function to register an @font-face
	 */
	exports.fontFace = ts.fontFace;
	/**
	 * Allows use to use the stylesheet in a node.js environment
	 */
	exports.getStyles = ts.getStyles;
	/**
	 * Takes keyframes and returns a generated animationName
	 */
	exports.keyframes = ts.keyframes;
	/**
	 * Helps with testing. Reinitializes FreeStyle + raw
	 */
	exports.reinit = ts.reinit;
	/**
	 * Takes CSSProperties and return a generated className you can use on your component
	 */
	exports.style = ts.style;
	/**
	 * Creates a new instance of TypeStyle separate from the default instance.
	 *
	 * - Use this for creating a different typestyle instance for a shadow dom component.
	 * - Use this if you don't want an auto tag generated and you just want to collect the CSS.
	 *
	 * NOTE: styles aren't shared between different instances.
	 */
	function createTypeStyle(target) {
	    var instance = new typestyle_1.TypeStyle({ autoGenerateTag: false });
	    if (target) {
	        instance.setStylesTarget(target);
	    }
	    return instance;
	}
	exports.createTypeStyle = createTypeStyle;


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var formatting_1 = __webpack_require__(2);
	var utilities_1 = __webpack_require__(5);
	var FreeStyle = __webpack_require__(3);
	/**
	 * Creates an instance of free style with our options
	 */
	var createFreeStyle = function () { return FreeStyle.create(
	/** Use the default hash function */
	undefined, 
	/** Preserve $debugName values */
	true); };
	/**
	 * Maintains a single stylesheet and keeps it in sync with requested styles
	 */
	var TypeStyle = (function () {
	    function TypeStyle(_a) {
	        var autoGenerateTag = _a.autoGenerateTag;
	        var _this = this;
	        /**
	         * Insert `raw` CSS as a string. This is useful for e.g.
	         * - third party CSS that you are customizing with template strings
	         * - generating raw CSS in JavaScript
	         * - reset libraries like normalize.css that you can use without loaders
	         */
	        this.cssRaw = function (mustBeValidCSS) {
	            if (!mustBeValidCSS) {
	                return;
	            }
	            _this._raw += mustBeValidCSS || '';
	            _this._pendingRawChange = true;
	            _this._styleUpdated();
	        };
	        /**
	         * Takes CSSProperties and registers it to a global selector (body, html, etc.)
	         */
	        this.cssRule = function (selector) {
	            var objects = [];
	            for (var _i = 1; _i < arguments.length; _i++) {
	                objects[_i - 1] = arguments[_i];
	            }
	            var object = formatting_1.ensureStringObj(utilities_1.extend.apply(void 0, objects)).result;
	            _this._freeStyle.registerRule(selector, object);
	            _this._styleUpdated();
	            return;
	        };
	        /**
	         * Renders styles to the singleton tag imediately
	         * NOTE: You should only call it on initial render to prevent any non CSS flash.
	         * After that it is kept sync using `requestAnimationFrame` and we haven't noticed any bad flashes.
	         **/
	        this.forceRenderStyles = function () {
	            var target = _this._getTag();
	            if (!target) {
	                return;
	            }
	            target.textContent = _this.getStyles();
	        };
	        /**
	         * Utility function to register an @font-face
	         */
	        this.fontFace = function () {
	            var fontFace = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                fontFace[_i] = arguments[_i];
	            }
	            var freeStyle = _this._freeStyle;
	            for (var _a = 0, _b = fontFace; _a < _b.length; _a++) {
	                var face = _b[_a];
	                freeStyle.registerRule('@font-face', face);
	            }
	            _this._styleUpdated();
	            return;
	        };
	        /**
	         * Allows use to use the stylesheet in a node.js environment
	         */
	        this.getStyles = function () {
	            return (_this._raw || '') + _this._freeStyle.getStyles();
	        };
	        /**
	         * Takes keyframes and returns a generated animationName
	         */
	        this.keyframes = function (frames) {
	            var _a = formatting_1.explodeKeyframes(frames), keyframes = _a.keyframes, $debugName = _a.$debugName;
	            // TODO: replace $debugName with display name
	            var animationName = _this._freeStyle.registerKeyframes(keyframes, $debugName);
	            _this._styleUpdated();
	            return animationName;
	        };
	        /**
	         * Helps with testing. Reinitializes FreeStyle + raw
	         */
	        this.reinit = function () {
	            /** reinit freestyle */
	            var freeStyle = createFreeStyle();
	            _this._freeStyle = freeStyle;
	            _this._lastFreeStyleChangeId = freeStyle.changeId;
	            /** reinit raw */
	            _this._raw = '';
	            _this._pendingRawChange = false;
	            /** Clear any styles that were flushed */
	            var target = _this._getTag();
	            if (target) {
	                target.textContent = '';
	            }
	        };
	        /** Sets the target tag where we write the css on style updates */
	        this.setStylesTarget = function (tag) {
	            /** Clear any data in any previous tag */
	            if (_this._tag) {
	                _this._tag.textContent = '';
	            }
	            _this._tag = tag;
	            /** This special time buffer immediately */
	            _this.forceRenderStyles();
	        };
	        /**
	         * Takes CSSProperties and return a generated className you can use on your component
	         */
	        this.style = function () {
	            var objects = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                objects[_i] = arguments[_i];
	            }
	            var freeStyle = _this._freeStyle;
	            var _a = formatting_1.ensureStringObj(utilities_1.extend.apply(void 0, objects)), result = _a.result, debugName = _a.debugName;
	            var className = debugName ? freeStyle.registerStyle(result, debugName) : freeStyle.registerStyle(result);
	            _this._styleUpdated();
	            return className;
	        };
	        var freeStyle = createFreeStyle();
	        this._autoGenerateTag = autoGenerateTag;
	        this._freeStyle = freeStyle;
	        this._lastFreeStyleChangeId = freeStyle.changeId;
	        this._pending = 0;
	        this._pendingRawChange = false;
	        this._raw = '';
	        this._tag = undefined;
	    }
	    /**
	     * Only calls cb all sync operations settle
	     */
	    TypeStyle.prototype._afterAllSync = function (cb) {
	        var _this = this;
	        this._pending++;
	        var pending = this._pending;
	        utilities_1.raf(function () {
	            if (pending !== _this._pending) {
	                return;
	            }
	            cb();
	        });
	    };
	    TypeStyle.prototype._getTag = function () {
	        if (this._tag) {
	            return this._tag;
	        }
	        if (this._autoGenerateTag) {
	            var tag = typeof window === 'undefined'
	                ? { textContent: '' }
	                : document.createElement('style');
	            if (typeof document !== 'undefined') {
	                document.head.appendChild(tag);
	            }
	            this._tag = tag;
	            return tag;
	        }
	        return undefined;
	    };
	    /** Checks if the style tag needs updating and if so queues up the change */
	    TypeStyle.prototype._styleUpdated = function () {
	        var _this = this;
	        var changeId = this._freeStyle.changeId;
	        var lastChangeId = this._lastFreeStyleChangeId;
	        if (!this._pendingRawChange && changeId === lastChangeId) {
	            return;
	        }
	        this._lastFreeStyleChangeId = changeId;
	        this._pendingRawChange = false;
	        this._afterAllSync(function () { return _this.forceRenderStyles(); });
	    };
	    return TypeStyle;
	}());
	exports.TypeStyle = TypeStyle;


/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var FreeStyle = __webpack_require__(3);
	/**
	 * We need to do the following to *our* objects before passing to freestyle:
	 * - For any `$nest` directive move up to FreeStyle style nesting
	 * - For any `$unique` directive map to FreeStyle Unique
	 * - For any `$debugName` directive return the debug name
	 */
	function ensureStringObj(object) {
	    /** The final result we will return */
	    var result = {};
	    var debugName = '';
	    for (var key in object) {
	        /** Grab the value upfront */
	        var val = object[key];
	        /** TypeStyle configuration options */
	        if (key === '$unique') {
	            result[FreeStyle.IS_UNIQUE] = val;
	        }
	        else if (key === '$nest') {
	            var nested = val;
	            for (var selector in nested) {
	                var subproperties = nested[selector];
	                result[selector] = ensureStringObj(subproperties).result;
	            }
	        }
	        else if (key === '$debugName') {
	            debugName = val;
	        }
	        else {
	            result[key] = val;
	        }
	    }
	    return { result: result, debugName: debugName };
	}
	exports.ensureStringObj = ensureStringObj;
	// todo: better name here
	function explodeKeyframes(frames) {
	    var result = { $debugName: undefined, keyframes: {} };
	    for (var offset in frames) {
	        var val = frames[offset];
	        if (offset === '$debugName') {
	            result.$debugName = val;
	        }
	        else {
	            result.keyframes[offset] = val;
	        }
	    }
	    return result;
	}
	exports.explodeKeyframes = explodeKeyframes;


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {"use strict";
	var __extends = (this && this.__extends) || (function () {
	    var extendStatics = Object.setPrototypeOf ||
	        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(exports, "__esModule", { value: true });
	/**
	 * The unique id is used to get a unique hash on styles (no merging).
	 */
	var uniqueId = 0;
	/**
	 * Tag styles with this string to get unique hash outputs.
	 */
	exports.IS_UNIQUE = '__DO_NOT_DEDUPE_STYLE__';
	/**
	 * CSS properties that are valid unit-less numbers.
	 */
	var CSS_NUMBER = {
	    'animation-iteration-count': true,
	    'box-flex': true,
	    'box-flex-group': true,
	    'column-count': true,
	    'counter-increment': true,
	    'counter-reset': true,
	    'flex': true,
	    'flex-grow': true,
	    'flex-positive': true,
	    'flex-shrink': true,
	    'flex-negative': true,
	    'font-weight': true,
	    'line-clamp': true,
	    'line-height': true,
	    'opacity': true,
	    'order': true,
	    'orphans': true,
	    'tab-size': true,
	    'widows': true,
	    'z-index': true,
	    'zoom': true,
	    // SVG properties.
	    'fill-opacity': true,
	    'stroke-dashoffset': true,
	    'stroke-opacity': true,
	    'stroke-width': true
	};
	// Add vendor prefixes to all unit-less properties.
	for (var _i = 0, _a = ['-webkit-', '-ms-', '-moz-', '-o-']; _i < _a.length; _i++) {
	    var prefix = _a[_i];
	    for (var _b = 0, _c = Object.keys(CSS_NUMBER); _b < _c.length; _b++) {
	        var property = _c[_b];
	        CSS_NUMBER[prefix + property] = true;
	    }
	}
	/**
	 * Transform a JavaScript property into a CSS property.
	 */
	function hyphenate(propertyName) {
	    return propertyName
	        .replace(/([A-Z])/g, '-$1')
	        .replace(/^ms-/, '-ms-') // Internet Explorer vendor prefix.
	        .toLowerCase();
	}
	/**
	 * Check if a property name should pop to the top level of CSS.
	 */
	function isAtRule(propertyName) {
	    return propertyName.charAt(0) === '@';
	}
	/**
	 * Check if a value is a nested style definition.
	 */
	function isNestedStyle(value) {
	    return value != null && typeof value === 'object' && !Array.isArray(value);
	}
	/**
	 * Generate a hash value from a string.
	 */
	function stringHash(str) {
	    var value = 5381;
	    var i = str.length;
	    while (i) {
	        value = (value * 33) ^ str.charCodeAt(--i);
	    }
	    return (value >>> 0).toString(36);
	}
	exports.stringHash = stringHash;
	/**
	 * Transform a style string to a CSS string.
	 */
	function styleToString(key, value) {
	    if (typeof value === 'number' && value !== 0 && !CSS_NUMBER[key]) {
	        value = value + "px";
	    }
	    return key + ":" + String(value);
	}
	/**
	 * Sort an array of tuples by first value.
	 */
	function sortTuples(value) {
	    return value.sort(function (a, b) { return a[0] > b[0] ? 1 : -1; });
	}
	/**
	 * Categorize user styles.
	 */
	function parseStyles(styles, hasNestedStyles) {
	    var properties = [];
	    var nestedStyles = [];
	    var isUnique = false;
	    // Sort keys before adding to styles.
	    for (var _i = 0, _a = Object.keys(styles); _i < _a.length; _i++) {
	        var key = _a[_i];
	        var value = styles[key];
	        if (key === exports.IS_UNIQUE) {
	            isUnique = !!value;
	        }
	        else if (isNestedStyle(value)) {
	            nestedStyles.push([key.trim(), value]);
	        }
	        else {
	            properties.push([hyphenate(key.trim()), value]);
	        }
	    }
	    return {
	        properties: sortTuples(properties),
	        nestedStyles: hasNestedStyles ? nestedStyles : sortTuples(nestedStyles),
	        isUnique: isUnique
	    };
	}
	/**
	 * Stringify an array of property tuples.
	 */
	function stringifyProperties(properties) {
	    var result = [];
	    var _loop_1 = function (name, value) {
	        if (value != null) {
	            if (Array.isArray(value)) {
	                value.forEach(function (value) {
	                    value && result.push(styleToString(name, value));
	                });
	            }
	            else {
	                result.push(styleToString(name, value));
	            }
	        }
	    };
	    for (var _i = 0, properties_1 = properties; _i < properties_1.length; _i++) {
	        var _a = properties_1[_i], name = _a[0], value = _a[1];
	        _loop_1(name, value);
	    }
	    return result.join(';');
	}
	/**
	 * Interpolate CSS selectors.
	 */
	function interpolate(selector, parent) {
	    if (selector.indexOf('&') > -1) {
	        return selector.replace(/&/g, parent);
	    }
	    return parent + " " + selector;
	}
	/**
	 * Recursive loop building styles with deferred selectors.
	 */
	function stylize(cache, selector, styles, list, parent) {
	    var _a = parseStyles(styles, !!selector), properties = _a.properties, nestedStyles = _a.nestedStyles, isUnique = _a.isUnique;
	    var styleString = stringifyProperties(properties);
	    var pid = styleString;
	    if (isAtRule(selector)) {
	        var rule = cache.add(new Rule(selector, parent ? undefined : styleString, cache.hash));
	        // Nested styles support (e.g. `.foo > @media > .bar`).
	        if (styleString && parent) {
	            var style = rule.add(new Style(styleString, rule.hash, isUnique ? "u" + (++uniqueId).toString(36) : undefined));
	            list.push([parent, style]);
	        }
	        for (var _i = 0, nestedStyles_1 = nestedStyles; _i < nestedStyles_1.length; _i++) {
	            var _b = nestedStyles_1[_i], name = _b[0], value = _b[1];
	            pid += name + stylize(rule, name, value, list, parent);
	        }
	    }
	    else {
	        var key = parent ? interpolate(selector, parent) : selector;
	        if (styleString) {
	            var style = cache.add(new Style(styleString, cache.hash, isUnique ? "u" + (++uniqueId).toString(36) : undefined));
	            list.push([key, style]);
	        }
	        for (var _c = 0, nestedStyles_2 = nestedStyles; _c < nestedStyles_2.length; _c++) {
	            var _d = nestedStyles_2[_c], name = _d[0], value = _d[1];
	            pid += name + stylize(cache, name, value, list, key);
	        }
	    }
	    return pid;
	}
	/**
	 * Register all styles, but collect for selector interpolation using the hash.
	 */
	function composeStyles(container, selector, styles, isStyle, displayName) {
	    var cache = new Cache(container.hash);
	    var list = [];
	    var pid = stylize(cache, selector, styles, list);
	    var hash = "f" + cache.hash(pid);
	    var id = displayName ? displayName + "_" + hash : hash;
	    for (var _i = 0, list_1 = list; _i < list_1.length; _i++) {
	        var _a = list_1[_i], selector_1 = _a[0], style = _a[1];
	        var key = isStyle ? interpolate(selector_1, "." + id) : selector_1;
	        style.add(new Selector(key, style.hash, undefined, pid));
	    }
	    return { cache: cache, pid: pid, id: id };
	}
	/**
	 * Get the styles string for a container class.
	 */
	function getStyles(container) {
	    return container.values().map(function (style) { return style.getStyles(); }).join('');
	}
	/**
	 * Implement a cache/event emitter.
	 */
	var Cache = (function () {
	    function Cache(hash) {
	        this.hash = hash;
	        this.changeId = 0;
	        this._children = {};
	        this._keys = [];
	        this._counters = {};
	    }
	    Cache.prototype.values = function () {
	        var _this = this;
	        return this._keys.map(function (x) { return _this._children[x]; });
	    };
	    Cache.prototype.add = function (style) {
	        var count = this._counters[style.id] || 0;
	        var item = this._children[style.id] || style.clone();
	        this._counters[style.id] = count + 1;
	        if (count === 0) {
	            this._keys.push(item.id);
	            this._children[item.id] = item;
	            this.changeId++;
	        }
	        else {
	            // Check if contents are different.
	            if (item.getIdentifier() !== style.getIdentifier()) {
	                throw new TypeError("Hash collision: " + style.getStyles() + " === " + item.getStyles());
	            }
	            this._keys.splice(this._keys.indexOf(style.id), 1);
	            this._keys.push(style.id);
	            if (item instanceof Cache && style instanceof Cache) {
	                var prevChangeId = item.changeId;
	                item.merge(style);
	                if (item.changeId !== prevChangeId) {
	                    this.changeId++;
	                }
	            }
	        }
	        return item;
	    };
	    Cache.prototype.remove = function (style) {
	        var count = this._counters[style.id];
	        if (count > 0) {
	            this._counters[style.id] = count - 1;
	            var item = this._children[style.id];
	            if (count === 1) {
	                delete this._counters[style.id];
	                delete this._children[style.id];
	                this._keys.splice(this._keys.indexOf(style.id), 1);
	                this.changeId++;
	            }
	            else if (item instanceof Cache && style instanceof Cache) {
	                var prevChangeId = item.changeId;
	                item.unmerge(style);
	                if (item.changeId !== prevChangeId) {
	                    this.changeId++;
	                }
	            }
	        }
	    };
	    Cache.prototype.merge = function (cache) {
	        for (var _i = 0, _a = cache.values(); _i < _a.length; _i++) {
	            var value = _a[_i];
	            this.add(value);
	        }
	        return this;
	    };
	    Cache.prototype.unmerge = function (cache) {
	        for (var _i = 0, _a = cache.values(); _i < _a.length; _i++) {
	            var value = _a[_i];
	            this.remove(value);
	        }
	        return this;
	    };
	    Cache.prototype.clone = function () {
	        return new Cache(this.hash).merge(this);
	    };
	    return Cache;
	}());
	exports.Cache = Cache;
	/**
	 * Selector is a dumb class made to represent nested CSS selectors.
	 */
	var Selector = (function () {
	    function Selector(selector, hash, id, pid) {
	        if (id === void 0) { id = "s" + hash(selector); }
	        if (pid === void 0) { pid = ''; }
	        this.selector = selector;
	        this.hash = hash;
	        this.id = id;
	        this.pid = pid;
	    }
	    Selector.prototype.getStyles = function () {
	        return this.selector;
	    };
	    Selector.prototype.getIdentifier = function () {
	        return this.pid + "." + this.selector;
	    };
	    Selector.prototype.clone = function () {
	        return new Selector(this.selector, this.hash, this.id, this.pid);
	    };
	    return Selector;
	}());
	exports.Selector = Selector;
	/**
	 * The style container registers a style string with selectors.
	 */
	var Style = (function (_super) {
	    __extends(Style, _super);
	    function Style(style, hash, id) {
	        if (id === void 0) { id = "c" + hash(style); }
	        var _this = _super.call(this, hash) || this;
	        _this.style = style;
	        _this.hash = hash;
	        _this.id = id;
	        return _this;
	    }
	    Style.prototype.getStyles = function () {
	        return this.values().map(function (x) { return x.getStyles(); }).join(',') + "{" + this.style + "}";
	    };
	    Style.prototype.getIdentifier = function () {
	        return this.style;
	    };
	    Style.prototype.clone = function () {
	        return new Style(this.style, this.hash, this.id).merge(this);
	    };
	    return Style;
	}(Cache));
	exports.Style = Style;
	/**
	 * Implement rule logic for style output.
	 */
	var Rule = (function (_super) {
	    __extends(Rule, _super);
	    function Rule(rule, style, hash, id, pid) {
	        if (style === void 0) { style = ''; }
	        if (id === void 0) { id = "a" + hash(rule + "." + style); }
	        if (pid === void 0) { pid = ''; }
	        var _this = _super.call(this, hash) || this;
	        _this.rule = rule;
	        _this.style = style;
	        _this.hash = hash;
	        _this.id = id;
	        _this.pid = pid;
	        return _this;
	    }
	    Rule.prototype.getStyles = function () {
	        return this.rule + "{" + this.style + getStyles(this) + "}";
	    };
	    Rule.prototype.getIdentifier = function () {
	        return this.pid + "." + this.rule + "." + this.style;
	    };
	    Rule.prototype.clone = function () {
	        return new Rule(this.rule, this.style, this.hash, this.id, this.pid).merge(this);
	    };
	    return Rule;
	}(Cache));
	exports.Rule = Rule;
	/**
	 * The FreeStyle class implements the API for everything else.
	 */
	var FreeStyle = (function (_super) {
	    __extends(FreeStyle, _super);
	    function FreeStyle(hash, debug, id) {
	        if (id === void 0) { id = "f" + (++uniqueId).toString(36); }
	        var _this = _super.call(this, hash) || this;
	        _this.hash = hash;
	        _this.debug = debug;
	        _this.id = id;
	        return _this;
	    }
	    FreeStyle.prototype.registerStyle = function (styles, displayName) {
	        var _a = composeStyles(this, '&', styles, true, this.debug ? displayName : undefined), cache = _a.cache, id = _a.id;
	        this.merge(cache);
	        return id;
	    };
	    FreeStyle.prototype.registerKeyframes = function (keyframes, displayName) {
	        return this.registerHashRule('@keyframes', keyframes, displayName);
	    };
	    FreeStyle.prototype.registerHashRule = function (prefix, styles, displayName) {
	        var _a = composeStyles(this, '', styles, false, this.debug ? displayName : undefined), cache = _a.cache, pid = _a.pid, id = _a.id;
	        var rule = new Rule(prefix + " " + id, undefined, this.hash, undefined, pid);
	        this.add(rule.merge(cache));
	        return id;
	    };
	    FreeStyle.prototype.registerRule = function (rule, styles) {
	        this.merge(composeStyles(this, rule, styles, false).cache);
	    };
	    FreeStyle.prototype.registerCss = function (styles) {
	        this.merge(composeStyles(this, '', styles, false).cache);
	    };
	    FreeStyle.prototype.getStyles = function () {
	        return getStyles(this);
	    };
	    FreeStyle.prototype.getIdentifier = function () {
	        return this.id;
	    };
	    FreeStyle.prototype.clone = function () {
	        return new FreeStyle(this.hash, this.debug, this.id).merge(this);
	    };
	    return FreeStyle;
	}(Cache));
	exports.FreeStyle = FreeStyle;
	/**
	 * Exports a simple function to create a new instance.
	 */
	function create(hash, debug) {
	    if (hash === void 0) { hash = stringHash; }
	    if (debug === void 0) { debug = typeof process !== 'undefined' && process.env['NODE_ENV'] !== 'production'; }
	    return new FreeStyle(hash, debug);
	}
	exports.create = create;
	//# sourceMappingURL=free-style.js.map
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 4 */
/***/ function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};

	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.

	var cachedSetTimeout;
	var cachedClearTimeout;

	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }


	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }



	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}

	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};

	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};

	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 5 */
/***/ function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	/** Raf for node + browser */
	exports.raf = typeof requestAnimationFrame === 'undefined' ? setTimeout : requestAnimationFrame.bind(window);
	/**
	 * Utility to join classes conditionally
	 */
	function classes() {
	    var classes = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        classes[_i] = arguments[_i];
	    }
	    return classes.filter(function (c) { return !!c; }).join(' ');
	}
	exports.classes = classes;
	/**
	 * Merges various styles into a single style object.
	 * Note: if two objects have the same property the last one wins
	 */
	function extend() {
	    var objects = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        objects[_i] = arguments[_i];
	    }
	    /** The final result we will return */
	    var result = {};
	    for (var _a = 0, objects_1 = objects; _a < objects_1.length; _a++) {
	        var object = objects_1[_a];
	        if (object == null || object === false) {
	            continue;
	        }
	        for (var key in object) {
	            /** Falsy values except a explicit 0 is ignored */
	            var val = object[key];
	            if (!val && val !== 0) {
	                continue;
	            }
	            /** if nested media or pseudo selector */
	            if (key === '$nest' && val) {
	                result[key] = result['$nest'] ? extend(result['$nest'], val) : val;
	            }
	            else if ((key.indexOf('&') !== -1 || key.indexOf('@media') === 0)) {
	                result[key] = result[key] ? extend(result[key], val) : val;
	            }
	            else {
	                result[key] = val;
	            }
	        }
	    }
	    return result;
	}
	exports.extend = extend;
	/**
	 * Utility to help customize styles with media queries. e.g.
	 * ```
	 * style(
	 *  media({maxWidth:500}, {color:'red'})
	 * )
	 * ```
	 */
	exports.media = function (mediaQuery) {
	    var objects = [];
	    for (var _i = 1; _i < arguments.length; _i++) {
	        objects[_i - 1] = arguments[_i];
	    }
	    var mediaQuerySections = [];
	    if (mediaQuery.type)
	        mediaQuerySections.push(mediaQuery.type);
	    if (mediaQuery.orientation)
	        mediaQuerySections.push(mediaQuery.orientation);
	    if (mediaQuery.minWidth)
	        mediaQuerySections.push("(min-width: " + mediaLength(mediaQuery.minWidth) + ")");
	    if (mediaQuery.maxWidth)
	        mediaQuerySections.push("(max-width: " + mediaLength(mediaQuery.maxWidth) + ")");
	    if (mediaQuery.minHeight)
	        mediaQuerySections.push("(min-height: " + mediaLength(mediaQuery.minHeight) + ")");
	    if (mediaQuery.maxHeight)
	        mediaQuerySections.push("(max-height: " + mediaLength(mediaQuery.maxHeight) + ")");
	    var stringMediaQuery = "@media " + mediaQuerySections.join(' and ');
	    var object = {
	        $nest: (_a = {},
	            _a[stringMediaQuery] = extend.apply(void 0, objects),
	            _a)
	    };
	    return object;
	    var _a;
	};
	var mediaLength = function (value) {
	    return typeof value === 'string' ? value : value + "px";
	};


/***/ },
/* 6 */
/***/ function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });


/***/ }
/******/ ])
});
;